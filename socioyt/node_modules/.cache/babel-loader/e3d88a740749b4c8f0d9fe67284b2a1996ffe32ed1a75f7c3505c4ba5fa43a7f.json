{"ast":null,"code":"import { useRef, useCallback } from 'react';\nimport useSWR from '../index/index.mjs';\nimport { withMiddleware, SWRGlobalState, cache, INFINITE_PREFIX as INFINITE_PREFIX$1, createCacheHelper, isUndefined as isUndefined$1, useIsomorphicLayoutEffect, UNDEFINED as UNDEFINED$1, serialize as serialize$1, isFunction as isFunction$1 } from '../_internal/index.mjs';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\n\n// Shared state between server components and client components\nconst noop = () => {};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/noop();\nconst OBJECT = Object;\nconst isUndefined = v => v === UNDEFINED;\nconst isFunction = v => typeof v == 'function';\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\nconst isObjectType = (value, type) => OBJECT.prototype.toString.call(value) === `[object ${type}]`;\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = arg => {\n  const type = typeof arg;\n  const isDate = isObjectType(arg, 'Date');\n  const isRegex = isObjectType(arg, 'RegExp');\n  const isPlainObject = isObjectType(arg, 'Object');\n  let result;\n  let index;\n  if (OBJECT(arg) === arg && !isDate && !isRegex) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    result = table.get(arg);\n    if (result) return result;\n    // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n    result = ++counter + '~';\n    table.set(arg, result);\n    if (Array.isArray(arg)) {\n      // Array.\n      result = '@';\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + ',';\n      }\n      table.set(arg, result);\n    }\n    if (isPlainObject) {\n      // Object, sort keys.\n      result = '#';\n      const keys = OBJECT.keys(arg).sort();\n      while (!isUndefined(index = keys.pop())) {\n        if (!isUndefined(arg[index])) {\n          result += index + ':' + stableHash(arg[index]) + ',';\n        }\n      }\n      table.set(arg, result);\n    }\n  } else {\n    result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n  }\n  return result;\n};\nconst serialize = key => {\n  if (isFunction(key)) {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  }\n  // Use the original key as the argument of fetcher. This can be a string or an\n  // array of values.\n  const args = key;\n  // If key is not falsy, or not an empty array, hash it.\n  key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n  return [key, args];\n};\nconst INFINITE_PREFIX = '$inf$';\nconst getFirstPageKey = getKey => {\n  return serialize(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = getKey => {\n  return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\n\n// We have to several type castings here because `useSWRInfinite` is a special\n// hook where `key` and return type are not like the normal `useSWR` types.\nconst EMPTY_PROMISE = Promise.resolve();\nconst infinite = useSWRNext => (getKey, fn, config) => {\n  const didMountRef = useRef(false);\n  const {\n    cache: cache$1,\n    initialSize = 1,\n    revalidateAll = false,\n    persistSize = false,\n    revalidateFirstPage = true,\n    revalidateOnMount = false,\n    parallel = false\n  } = config;\n  const [,,, PRELOAD] = SWRGlobalState.get(cache);\n  // The serialized key of the first page. This key will be used to store\n  // metadata of this SWR infinite hook.\n  let infiniteKey;\n  try {\n    infiniteKey = getFirstPageKey(getKey);\n    if (infiniteKey) infiniteKey = INFINITE_PREFIX$1 + infiniteKey;\n  } catch (err) {\n    // Not ready yet.\n  }\n  const [get, set, subscribeCache] = createCacheHelper(cache$1, infiniteKey);\n  const getSnapshot = useCallback(() => {\n    const size = isUndefined$1(get()._l) ? initialSize : get()._l;\n    return size;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cache$1, infiniteKey, initialSize]);\n  useSyncExternalStore(useCallback(callback => {\n    if (infiniteKey) return subscribeCache(infiniteKey, () => {\n      callback();\n    });\n    return () => {};\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [cache$1, infiniteKey]), getSnapshot, getSnapshot);\n  const resolvePageSize = useCallback(() => {\n    const cachedPageSize = get()._l;\n    return isUndefined$1(cachedPageSize) ? initialSize : cachedPageSize;\n    // `cache` isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [infiniteKey, initialSize]);\n  // keep the last page size to restore it with the persistSize option\n  const lastPageSizeRef = useRef(resolvePageSize());\n  // When the page key changes, we reset the page size if it's not persisted\n  useIsomorphicLayoutEffect(() => {\n    if (!didMountRef.current) {\n      didMountRef.current = true;\n      return;\n    }\n    if (infiniteKey) {\n      // If the key has been changed, we keep the current page size if persistSize is enabled\n      // Otherwise, we reset the page size to cached pageSize\n      set({\n        _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n      });\n    }\n    // `initialSize` isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [infiniteKey, cache$1]);\n  // Needs to check didMountRef during mounting, not in the fetcher\n  const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n  // Actual SWR hook to load all pages in one fetcher.\n  const swr = useSWRNext(infiniteKey, async key => {\n    // get the revalidate context\n    const forceRevalidateAll = get()._i;\n    const shouldRevalidatePage = get()._r;\n    set({\n      _r: UNDEFINED$1\n    });\n    // return an array of page data\n    const data = [];\n    const pageSize = resolvePageSize();\n    const [getCache] = createCacheHelper(cache$1, key);\n    const cacheData = getCache().data;\n    const revalidators = [];\n    let previousPageData = null;\n    for (let i = 0; i < pageSize; ++i) {\n      const [pageKey, pageArg] = serialize$1(getKey(i, parallel ? null : previousPageData));\n      if (!pageKey) {\n        break;\n      }\n      const [getSWRCache, setSWRCache] = createCacheHelper(cache$1, pageKey);\n      // Get the cached page data.\n      let pageData = getSWRCache().data;\n      // should fetch (or revalidate) if:\n      // - `revalidateAll` is enabled\n      // - `mutate()` called\n      // - the cache is missing\n      // - it's the first page and it's not the initial render\n      // - `revalidateOnMount` is enabled and it's on mount\n      // - cache for that page has changed\n      const shouldFetchPage = revalidateAll || forceRevalidateAll || isUndefined$1(pageData) || revalidateFirstPage && !i && !isUndefined$1(cacheData) || shouldRevalidateOnMount || cacheData && !isUndefined$1(cacheData[i]) && !config.compare(cacheData[i], pageData);\n      if (fn && (typeof shouldRevalidatePage === 'function' ? shouldRevalidatePage(pageData, pageArg) : shouldFetchPage)) {\n        const revalidate = async () => {\n          const hasPreloadedRequest = pageKey in PRELOAD;\n          if (!hasPreloadedRequest) {\n            pageData = await fn(pageArg);\n          } else {\n            const req = PRELOAD[pageKey];\n            // delete the preload cache key before resolving it\n            // in case there's an error\n            delete PRELOAD[pageKey];\n            // get the page data from the preload cache\n            pageData = await req;\n          }\n          setSWRCache({\n            data: pageData,\n            _k: pageArg\n          });\n          data[i] = pageData;\n        };\n        if (parallel) {\n          revalidators.push(revalidate);\n        } else {\n          await revalidate();\n        }\n      } else {\n        data[i] = pageData;\n      }\n      if (!parallel) {\n        previousPageData = pageData;\n      }\n    }\n    // flush all revalidateions in parallel\n    if (parallel) {\n      await Promise.all(revalidators.map(r => r()));\n    }\n    // once we executed the data fetching based on the context, clear the context\n    set({\n      _i: UNDEFINED$1\n    });\n    // return the data\n    return data;\n  }, config);\n  const mutate = useCallback(\n  // eslint-disable-next-line func-names\n  function (data, opts) {\n    // When passing as a boolean, it's explicitly used to disable/enable\n    // revalidation.\n    const options = typeof opts === 'boolean' ? {\n      revalidate: opts\n    } : opts || {};\n    // Default to true.\n    const shouldRevalidate = options.revalidate !== false;\n    // It is possible that the key is still falsy.\n    if (!infiniteKey) return EMPTY_PROMISE;\n    if (shouldRevalidate) {\n      if (!isUndefined$1(data)) {\n        // We only revalidate the pages that are changed\n        set({\n          _i: false,\n          _r: options.revalidate\n        });\n      } else {\n        // Calling `mutate()`, we revalidate all pages\n        set({\n          _i: true,\n          _r: options.revalidate\n        });\n      }\n    }\n    return arguments.length ? swr.mutate(data, {\n      ...options,\n      revalidate: shouldRevalidate\n    }) : swr.mutate();\n  },\n  // swr.mutate is always the same reference\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [infiniteKey, cache$1]);\n  // Extend the SWR API\n  const setSize = useCallback(arg => {\n    // It is possible that the key is still falsy.\n    if (!infiniteKey) return EMPTY_PROMISE;\n    const [, changeSize] = createCacheHelper(cache$1, infiniteKey);\n    let size;\n    if (isFunction$1(arg)) {\n      size = arg(resolvePageSize());\n    } else if (typeof arg == 'number') {\n      size = arg;\n    }\n    if (typeof size != 'number') return EMPTY_PROMISE;\n    changeSize({\n      _l: size\n    });\n    lastPageSizeRef.current = size;\n    // Calculate the page data after the size change.\n    const data = [];\n    const [getInfiniteCache] = createCacheHelper(cache$1, infiniteKey);\n    let previousPageData = null;\n    for (let i = 0; i < size; ++i) {\n      const [pageKey] = serialize$1(getKey(i, previousPageData));\n      const [getCache] = createCacheHelper(cache$1, pageKey);\n      // Get the cached page data.\n      const pageData = pageKey ? getCache().data : UNDEFINED$1;\n      // Call `mutate` with infinte cache data if we can't get it from the page cache.\n      if (isUndefined$1(pageData)) {\n        return mutate(getInfiniteCache().data);\n      }\n      data.push(pageData);\n      previousPageData = pageData;\n    }\n    return mutate(data);\n  },\n  // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [infiniteKey, cache$1, mutate, resolvePageSize]);\n  // Use getter functions to avoid unnecessary re-renders caused by triggering\n  // all the getters of the returned swr object.\n  return {\n    size: resolvePageSize(),\n    setSize,\n    mutate,\n    get data() {\n      return swr.data;\n    },\n    get error() {\n      return swr.error;\n    },\n    get isValidating() {\n      return swr.isValidating;\n    },\n    get isLoading() {\n      return swr.isLoading;\n    }\n  };\n};\nconst useSWRInfinite = withMiddleware(useSWR, infinite);\nexport { useSWRInfinite as default, infinite, unstable_serialize };","map":{"version":3,"names":["useRef","useCallback","useSWR","withMiddleware","SWRGlobalState","cache","INFINITE_PREFIX","INFINITE_PREFIX$1","createCacheHelper","isUndefined","isUndefined$1","useIsomorphicLayoutEffect","UNDEFINED","UNDEFINED$1","serialize","serialize$1","isFunction","isFunction$1","useSyncExternalStore","noop","OBJECT","Object","v","table","WeakMap","isObjectType","value","type","prototype","toString","call","counter","stableHash","arg","isDate","isRegex","isPlainObject","result","index","get","set","Array","isArray","length","keys","sort","pop","toJSON","JSON","stringify","key","err","args","getFirstPageKey","getKey","unstable_serialize","EMPTY_PROMISE","Promise","resolve","infinite","useSWRNext","fn","config","didMountRef","cache$1","initialSize","revalidateAll","persistSize","revalidateFirstPage","revalidateOnMount","parallel","PRELOAD","infiniteKey","subscribeCache","getSnapshot","size","_l","callback","resolvePageSize","cachedPageSize","lastPageSizeRef","current","shouldRevalidateOnMount","swr","forceRevalidateAll","_i","shouldRevalidatePage","_r","data","pageSize","getCache","cacheData","revalidators","previousPageData","i","pageKey","pageArg","getSWRCache","setSWRCache","pageData","shouldFetchPage","compare","revalidate","hasPreloadedRequest","req","_k","push","all","map","r","mutate","opts","options","shouldRevalidate","arguments","setSize","changeSize","getInfiniteCache","error","isValidating","isLoading","useSWRInfinite","default"],"sources":["/home/usl-sz-0158/Downloads/assessment/socioyt/node_modules/swr/dist/infinite/index.mjs"],"sourcesContent":["import { useRef, useCallback } from 'react';\nimport useSWR from '../index/index.mjs';\nimport { withMiddleware, SWRGlobalState, cache, INFINITE_PREFIX as INFINITE_PREFIX$1, createCacheHelper, isUndefined as isUndefined$1, useIsomorphicLayoutEffect, UNDEFINED as UNDEFINED$1, serialize as serialize$1, isFunction as isFunction$1 } from '../_internal/index.mjs';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\nconst isObjectType = (value, type)=>OBJECT.prototype.toString.call(value) === `[object ${type}]`;\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const isDate = isObjectType(arg, 'Date');\n    const isRegex = isObjectType(arg, 'RegExp');\n    const isPlainObject = isObjectType(arg, 'Object');\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && !isRegex) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (Array.isArray(arg)) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (isPlainObject) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\nconst INFINITE_PREFIX = '$inf$';\n\nconst getFirstPageKey = (getKey)=>{\n    return serialize(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = (getKey)=>{\n    return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\n\n// We have to several type castings here because `useSWRInfinite` is a special\n// hook where `key` and return type are not like the normal `useSWR` types.\nconst EMPTY_PROMISE = Promise.resolve();\nconst infinite = (useSWRNext)=>(getKey, fn, config)=>{\n        const didMountRef = useRef(false);\n        const { cache: cache$1, initialSize = 1, revalidateAll = false, persistSize = false, revalidateFirstPage = true, revalidateOnMount = false, parallel = false } = config;\n        const [, , , PRELOAD] = SWRGlobalState.get(cache);\n        // The serialized key of the first page. This key will be used to store\n        // metadata of this SWR infinite hook.\n        let infiniteKey;\n        try {\n            infiniteKey = getFirstPageKey(getKey);\n            if (infiniteKey) infiniteKey = INFINITE_PREFIX$1 + infiniteKey;\n        } catch (err) {\n        // Not ready yet.\n        }\n        const [get, set, subscribeCache] = createCacheHelper(cache$1, infiniteKey);\n        const getSnapshot = useCallback(()=>{\n            const size = isUndefined$1(get()._l) ? initialSize : get()._l;\n            return size;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            cache$1,\n            infiniteKey,\n            initialSize\n        ]);\n        useSyncExternalStore(useCallback((callback)=>{\n            if (infiniteKey) return subscribeCache(infiniteKey, ()=>{\n                callback();\n            });\n            return ()=>{};\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            cache$1,\n            infiniteKey\n        ]), getSnapshot, getSnapshot);\n        const resolvePageSize = useCallback(()=>{\n            const cachedPageSize = get()._l;\n            return isUndefined$1(cachedPageSize) ? initialSize : cachedPageSize;\n        // `cache` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            initialSize\n        ]);\n        // keep the last page size to restore it with the persistSize option\n        const lastPageSizeRef = useRef(resolvePageSize());\n        // When the page key changes, we reset the page size if it's not persisted\n        useIsomorphicLayoutEffect(()=>{\n            if (!didMountRef.current) {\n                didMountRef.current = true;\n                return;\n            }\n            if (infiniteKey) {\n                // If the key has been changed, we keep the current page size if persistSize is enabled\n                // Otherwise, we reset the page size to cached pageSize\n                set({\n                    _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n                });\n            }\n        // `initialSize` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            cache$1\n        ]);\n        // Needs to check didMountRef during mounting, not in the fetcher\n        const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n        // Actual SWR hook to load all pages in one fetcher.\n        const swr = useSWRNext(infiniteKey, async (key)=>{\n            // get the revalidate context\n            const forceRevalidateAll = get()._i;\n            const shouldRevalidatePage = get()._r;\n            set({\n                _r: UNDEFINED$1\n            });\n            // return an array of page data\n            const data = [];\n            const pageSize = resolvePageSize();\n            const [getCache] = createCacheHelper(cache$1, key);\n            const cacheData = getCache().data;\n            const revalidators = [];\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                const [pageKey, pageArg] = serialize$1(getKey(i, parallel ? null : previousPageData));\n                if (!pageKey) {\n                    break;\n                }\n                const [getSWRCache, setSWRCache] = createCacheHelper(cache$1, pageKey);\n                // Get the cached page data.\n                let pageData = getSWRCache().data;\n                // should fetch (or revalidate) if:\n                // - `revalidateAll` is enabled\n                // - `mutate()` called\n                // - the cache is missing\n                // - it's the first page and it's not the initial render\n                // - `revalidateOnMount` is enabled and it's on mount\n                // - cache for that page has changed\n                const shouldFetchPage = revalidateAll || forceRevalidateAll || isUndefined$1(pageData) || revalidateFirstPage && !i && !isUndefined$1(cacheData) || shouldRevalidateOnMount || cacheData && !isUndefined$1(cacheData[i]) && !config.compare(cacheData[i], pageData);\n                if (fn && (typeof shouldRevalidatePage === 'function' ? shouldRevalidatePage(pageData, pageArg) : shouldFetchPage)) {\n                    const revalidate = async ()=>{\n                        const hasPreloadedRequest = pageKey in PRELOAD;\n                        if (!hasPreloadedRequest) {\n                            pageData = await fn(pageArg);\n                        } else {\n                            const req = PRELOAD[pageKey];\n                            // delete the preload cache key before resolving it\n                            // in case there's an error\n                            delete PRELOAD[pageKey];\n                            // get the page data from the preload cache\n                            pageData = await req;\n                        }\n                        setSWRCache({\n                            data: pageData,\n                            _k: pageArg\n                        });\n                        data[i] = pageData;\n                    };\n                    if (parallel) {\n                        revalidators.push(revalidate);\n                    } else {\n                        await revalidate();\n                    }\n                } else {\n                    data[i] = pageData;\n                }\n                if (!parallel) {\n                    previousPageData = pageData;\n                }\n            }\n            // flush all revalidateions in parallel\n            if (parallel) {\n                await Promise.all(revalidators.map((r)=>r()));\n            }\n            // once we executed the data fetching based on the context, clear the context\n            set({\n                _i: UNDEFINED$1\n            });\n            // return the data\n            return data;\n        }, config);\n        const mutate = useCallback(// eslint-disable-next-line func-names\n        function(data, opts) {\n            // When passing as a boolean, it's explicitly used to disable/enable\n            // revalidation.\n            const options = typeof opts === 'boolean' ? {\n                revalidate: opts\n            } : opts || {};\n            // Default to true.\n            const shouldRevalidate = options.revalidate !== false;\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            if (shouldRevalidate) {\n                if (!isUndefined$1(data)) {\n                    // We only revalidate the pages that are changed\n                    set({\n                        _i: false,\n                        _r: options.revalidate\n                    });\n                } else {\n                    // Calling `mutate()`, we revalidate all pages\n                    set({\n                        _i: true,\n                        _r: options.revalidate\n                    });\n                }\n            }\n            return arguments.length ? swr.mutate(data, {\n                ...options,\n                revalidate: shouldRevalidate\n            }) : swr.mutate();\n        }, // swr.mutate is always the same reference\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1\n        ]);\n        // Extend the SWR API\n        const setSize = useCallback((arg)=>{\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            const [, changeSize] = createCacheHelper(cache$1, infiniteKey);\n            let size;\n            if (isFunction$1(arg)) {\n                size = arg(resolvePageSize());\n            } else if (typeof arg == 'number') {\n                size = arg;\n            }\n            if (typeof size != 'number') return EMPTY_PROMISE;\n            changeSize({\n                _l: size\n            });\n            lastPageSizeRef.current = size;\n            // Calculate the page data after the size change.\n            const data = [];\n            const [getInfiniteCache] = createCacheHelper(cache$1, infiniteKey);\n            let previousPageData = null;\n            for(let i = 0; i < size; ++i){\n                const [pageKey] = serialize$1(getKey(i, previousPageData));\n                const [getCache] = createCacheHelper(cache$1, pageKey);\n                // Get the cached page data.\n                const pageData = pageKey ? getCache().data : UNDEFINED$1;\n                // Call `mutate` with infinte cache data if we can't get it from the page cache.\n                if (isUndefined$1(pageData)) {\n                    return mutate(getInfiniteCache().data);\n                }\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            return mutate(data);\n        }, // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1,\n            mutate,\n            resolvePageSize\n        ]);\n        // Use getter functions to avoid unnecessary re-renders caused by triggering\n        // all the getters of the returned swr object.\n        return {\n            size: resolvePageSize(),\n            setSize,\n            mutate,\n            get data () {\n                return swr.data;\n            },\n            get error () {\n                return swr.error;\n            },\n            get isValidating () {\n                return swr.isValidating;\n            },\n            get isLoading () {\n                return swr.isLoading;\n            }\n        };\n    };\nconst useSWRInfinite = withMiddleware(useSWR, infinite);\n\nexport { useSWRInfinite as default, infinite, unstable_serialize };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}